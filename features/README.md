# üåê VOID: Unified AI Grocery Platform

VOID is an end-to-end AI platform designed to maximize delivery efficiency and profitability for a grocery store by unifying **Dynamic Pricing**, **Predictive Routing**, and **Automated Sales Intelligence**.

The system is built on a high-performance Go backend, enabling real-time communication via WebSockets and leveraging specialized Python modules for AI-driven calculations.

---

## üß† Integrated Feature Architecture

The core functionality is realized by linking three specialized AI Python modules to the central Go backend, which manages the application state, persistence, and real-time messaging.

### 1. üí∞ Dynamic Pricing Engine (`delfeeng.py` / Go Backend)

**Integration Point: Stage 2 - Cart & Place Order**

The delivery fee is calculated **before** the user confirms payment, ensuring transparency and reducing disputes.

| Component | Action | Function |
| :--- | :--- | :--- |
| **Frontend** | Sends `POST /api/v1/orders` (includes `pickup/dropoff` and `priority` choice). |
| **Go Backend** | Receives request; calls **Delivery Fee Service**. |
| **Delivery Fee Service** | Executes `delfeeng.calculate_total_fee()` logic (or a Go port of it). |
| **Input Data** | **Distance Fee:** Calculated from `pickup_lat/lon` and `dropoff_lat/lon`. **Traffic/Demand Fee:** Looked up from the Cache (updated by `stream.py`). **Priority Fee:** Based on the `priority: "express"` flag. |
| **Frontend** | Receives and displays the detailed fee breakdown, including the difference between the **Base Price** and the final **Surged Price**. |

---

### 2. üó∫Ô∏è Predictive Routing & Logistics (`rocket_routing.py` / Go Backend)

**Integration Point: Stage 2 & Stage 5 - Price Calculation & Live Delivery**

This feature uses an LSTM model to predict congestion and optimize routes, especially for **Express/Priority** orders.

| Component | Action | Function |
| :--- | :--- | :--- |
| **Initial Route (Stage 2)** | When placing an order, the Go Backend calls `rocket_routing.simulate_route()` (or an external routing service powered by its predictions) to get the **initial ETA** for the price breakdown. The `rocket=True` flag is passed if the user selects "express." |
| **Live Routing (Stage 5)** | After driver assignment, the **Route Engine** continuously monitors real-time traffic updates (from the implied `stream.py` data). |
| **Route Recalculation** | If traffic changes significantly, the engine re-runs a pathfinding algorithm (e.g., Dijkstra's), leveraging **LSTM-predicted congestion** from `rocket_routing.predict_congestion()` as its cost function. |
| **Real-Time Update** | New route details and ETAs are broadcast via `ws.Manager.BroadcastMessage` to the frontend and **Admin Dashboard** (`position_update`, `eta_update`). |

---

### 3. üõí Smart Cart Intelligence (`smartcart.py`)

**Integration Point: Stage 2 - Cart Building**

This module optimizes profitability by using machine learning to increase basket size *before* the checkout process begins.

| Component | Action | Function |
| :--- | :--- | :--- |
| **Frontend (Cart View)** | Triggers an API call (e.g., `GET /api/v1/recommendations`) whenever the cart contents change. |
| **Go Backend** | Calls the `smartcart.smart_cart_recommendations()` function (likely via an internal gRPC or HTTP call to a separate Python microservice). |
| **Input Data** | Uses the historical data (`sales.csv`) and product metadata (`skus.csv`) to: **1.** Train a Cosine Similarity model. **2.** Generate combined suggestions (Habit, Pairing, ML). |
| **Frontend** | Displays product suggestions in the cart or checkout modal (e.g., "Add milk? You bought it yesterday!"). |

---

### 4. üìà Admin & Predictive Analytics Dashboard (Streamlit UI)

**Integration Point: Fleet and Operational Management**

The Streamlit application provides a unified view of the entire system's performance, fed by the operational data generated by the core services and the data stream.

| Component | Data Source | Use Case |
| :--- | :--- | :--- |
| **Demand Heatmap** | Loads data from `heatmap_grid.csv` (generated by the `stream.py` pipeline). | Helps administrators **visually identify surge zones** and optimally stage drivers. |
| **Rider Performance** | Loads data from `rider_metrics.csv`. | Monitors **Avg Delivery Time** and **Delay** per rider to identify training or management needs. |
| **Delivery Analysis** | Loads data from `orders_extended.csv` and `peak_hours.csv`. | Provides historical context for dynamic pricing (e.g., validating surge multipliers based on actual **Average Delay by Hour**). |
| **Live Tracking** | The **Admin Dashboard UI** would ideally consume the same WebSocket broadcast (`ws://host/api/v1/ws`) as the user frontend to show all vehicles in real-time. |

---

## üöÄ Next Steps

To make this platform runnable and ready for frontend development, prioritize these infrastructure tasks:

1.  **Containerize Infrastructure:** Generate the `docker-compose.yml` file to seamlessly run **Postgres**, **Redis**, and the **Go VOID Backend**.
2.  **Seeding Automation:** Implement the `seed()` function invocation in `cmd/main.go` and create a simple script to seed the database with initial drivers and vehicles.
3.  **Reverse Proxy Setup:** Implement **Nginx** as a reverse proxy to manage traffic (e.g., separating HTTP API traffic from WebSocket traffic) and provide robust routing and load balancing.
